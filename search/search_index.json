{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"DuckORM The Duck-ORM package is an asynchronous ORM for Python, with support for Postgres and SQLite . ORM is built with: databases Requirements : Python 3.8+ Duck-ORM is still under development . Installation 1 $ pip install duck-orm Note Don't forget to install databases before installing duck-orm . Quickstart For this example we will create a connection to the SQLite database and create a model. 1 2 $ pip install databases [ sqlite ] $ pip install ipython Note that we want to use ipython here, because it supports using await expressions directly from the console. Creating the connection to the SQLite database: 1 2 3 4 5 from databases import Database from duck_orm.model import Model db = Database ( 'sqlite:///example.db' ) await db . connect () Defining a model: 1 2 3 4 5 6 7 8 9 10 11 12 13 from duck_orm.sql import fields as Field class Person ( Model ): __tablename__ = 'persons' __db__ = db id : int = Field . Integer ( primary_key = True , auto_increment = True ) first_name : str = Field . String ( unique = True ) last_name : str = Field . String ( not_null = True ) age : int = Field . BigInteger ( min_value = 18 ) # Table creation in the database. await Person . create () The __tablename__ attribute is used to define the table's name in the database. The __db__ attribute is the instance of the database connection. And then the definition of the fields, their types and restrictions. And finally, the table creation in the database. License DuckORM is built as an open-source tool and remains completely free(MIT license).","title":"Introduction"},{"location":"#duckorm","text":"The Duck-ORM package is an asynchronous ORM for Python, with support for Postgres and SQLite . ORM is built with: databases Requirements : Python 3.8+ Duck-ORM is still under development .","title":"DuckORM"},{"location":"#installation","text":"1 $ pip install duck-orm Note Don't forget to install databases before installing duck-orm .","title":"Installation"},{"location":"#quickstart","text":"For this example we will create a connection to the SQLite database and create a model. 1 2 $ pip install databases [ sqlite ] $ pip install ipython Note that we want to use ipython here, because it supports using await expressions directly from the console.","title":"Quickstart"},{"location":"#creating-the-connection-to-the-sqlite-database","text":"1 2 3 4 5 from databases import Database from duck_orm.model import Model db = Database ( 'sqlite:///example.db' ) await db . connect ()","title":"Creating the connection to the SQLite database:"},{"location":"#defining-a-model","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 from duck_orm.sql import fields as Field class Person ( Model ): __tablename__ = 'persons' __db__ = db id : int = Field . Integer ( primary_key = True , auto_increment = True ) first_name : str = Field . String ( unique = True ) last_name : str = Field . String ( not_null = True ) age : int = Field . BigInteger ( min_value = 18 ) # Table creation in the database. await Person . create () The __tablename__ attribute is used to define the table's name in the database. The __db__ attribute is the instance of the database connection. And then the definition of the fields, their types and restrictions. And finally, the table creation in the database.","title":"Defining a model:"},{"location":"#license","text":"DuckORM is built as an open-source tool and remains completely free(MIT license).","title":"License"},{"location":"CONTRIBUTING/","text":"Contributing You can contribute at will, you will always be welcome. But we have some rules to be followed so that everyone is well received by everyone and that everyone can contribute in a happy way. Add/Update Features You looked the application and thought of some feature that should be added to the project ? So you have two steps to follow: Open an issue detailing your idea You implement the functionality yourself Creating an issue On the project page, you can click on the Issues button and a new issue button will appear on the page, then just select and follow the following steps: Select the type of your issue: Bug, Feature or Discussion . Give your issue a good name. Detail very well about the purpose of the issue. Images if possible. Finaly, click on Submit new issue . Clone the repository On the home page of the repository there is a Fork button. When you click, just wait to complete the fork. And then it will create the repository in your account. And now just clone in your machine, this: 1 git clone https://github.com/<nome_de_usuario>/duck-orm When finished, you will have the repository on your computer and then just open in your preferred editor and make your changes. Before you should create your branch for your development. You must create your branch from the develop branch: 1 git checkout -b <nome_branch> For the name of the branch use the number of the issue to facilitate, ex: issue_17 . And now can begin the development. When you have finished make your changes, you should commit your changes, but first: 1 git add . The above command will prepare all modified files to be committed, going through all the changes that were made by you where you will decide if the change will be added(you must be inside the project folder to use the command). Now just commit the changes: 1 git commit -m \"<Sua_Mensagem>\" Remember to use message clear. If what you're solving already has an issue open, reference issue in commit. Ex: git commit -m \"#17 - Add contributing.md\" And finally, you will submit the changes to the remote repository: 1 git push --set-upstream origin <nome_branch> This is only the first time that submit a new branch to the remote repository, next times, just: 1 git push But that will only in your fork, the official repository will not have its changes now what ? Calm down, now that the Pull Request or PR to branch develop . Contribute to implementation: After having forked and clone the project, chosen your favorite text editor. Now it's time to code. But calm there, first of all, you should choose an issue you want to work with. If the issue is about functionality does not exist, you should create and say you're working on it, case it exists, you must say that you intend to work on the issue. And after done that, now yes are you ready to code . Understanding folders: The project code can be found in the folder duck_orm , we are accepting library name hints as well.. In the folder duck_orm/utils : Possui os arquivos que possuem fun\u00e7\u00f5es que podem ser usadas por todo o projeto. In the folder docs : Possui os arquivos de documenta\u00e7\u00e3o da biblioteca. In the folder duck_orm/sql : Possui todos os arquivos sobre as funcionalidades relacionadas com SQL, seja do Postgres e/ou SQLite. In the folder ./postgres : Possui a classe QueryPostgres que herda de QueryExecutor, onde \u00e9 respons\u00e1vel por gerar todos os c\u00f3digos SQL que ir\u00e3o funcionar no Postgres. Se algum SQL for diferente para o banco, ent\u00e3o basta sobrescrever a fun\u00e7\u00e3o e ent\u00e3o retornar o SQL suportado. In the folder ./sqlite : Possui a classe QuerySQLite que herda de QueryExecutor, onde \u00e9 respons\u00e1vel por gerar todos os c\u00f3digos SQL que ir\u00e3o funcionar no SQLite. Se algum SQL for diferente para o banco, ent\u00e3o basta sobrescrever a fun\u00e7\u00e3o e ent\u00e3o retornar o SQL suportado. In the file ./condition.py : Possui a classe que \u00e9 usada para adicionar filtros nas consultas do DuckORM. In the file ./fields.py : Possui todas as classes que representam os tipos que s\u00e3o suportados pelo DuckORM e que fazem o tratamento para os tipos SQL. In the file ./operator.py : Possui a classe que \u00e9 usada para adicionar validar os operatores condicionais, usados pela classe Condition . In the file ./relationship.py : Possui todas as classes que representam os tipos de relacionamentos que s\u00e3o suportados pelo DuckORM e que fazem o tratamento para os relacionamentos para SQL. In the file ./sql.py : Possui a classe QueryExecutor, na qual todos as classes Query{nome_banco} herdam. \u00c9 aqui onde \u00e9 montado todos os comandos SQL e caso um SQL seja diferentes entre os bancos suportados, basta sobrescrever o m\u00e9todo na classe Query{nome_banco}. In the file ./exceptions.py : Possui todas as exce\u00e7\u00f5es usadas no DuckORM. In the file ./model.py : Principal arquivo, \u00e9 aqui onde toda a m\u00e1gica acontece. Todos os m\u00e9todos que podem ser usados por um modelo est\u00e3o nesse aquivo. How to run the application: We use poetry for easier dependency management. So you need to install it: Install poetry: To install you can follow the steps of their own documentation here Now you should create virtualenv: 1 poetry shell This will create a virtualenv for this project. Now you need to install the dependencies: 1 poetry install You are now ready to implement your functionality/fix. Run the tests: 1 pytest . Entering the standards: We chose to follow the PEP 8 standard. To do this, install the Python extension for VSCode . Another solution is to use pycodestyle. Pycodestyle: You can install pycodestyle with the command: 1 poetry add pycodestyle To run pycodestyle: 1 pycodestyle . Performing a Pull Request - PR On your fork page a yellow message will appear asking you to make a Pull Request to the original repository. Clicking will open a page for you to fill in your PR information. Reference the issue you are working on using #<numero_da_issue> . Open your PR for the develop branch. Describe your modifications. Wait for your PR evaluation, and it may happen that we ask for some changes to be made.","title":"Contributing"},{"location":"CONTRIBUTING/#contributing","text":"You can contribute at will, you will always be welcome. But we have some rules to be followed so that everyone is well received by everyone and that everyone can contribute in a happy way.","title":"Contributing"},{"location":"CONTRIBUTING/#addupdate-features","text":"You looked the application and thought of some feature that should be added to the project ? So you have two steps to follow: Open an issue detailing your idea You implement the functionality yourself","title":"Add/Update Features"},{"location":"CONTRIBUTING/#creating-an-issue","text":"On the project page, you can click on the Issues button and a new issue button will appear on the page, then just select and follow the following steps: Select the type of your issue: Bug, Feature or Discussion . Give your issue a good name. Detail very well about the purpose of the issue. Images if possible. Finaly, click on Submit new issue .","title":"Creating an issue"},{"location":"CONTRIBUTING/#clone-the-repository","text":"On the home page of the repository there is a Fork button. When you click, just wait to complete the fork. And then it will create the repository in your account. And now just clone in your machine, this: 1 git clone https://github.com/<nome_de_usuario>/duck-orm When finished, you will have the repository on your computer and then just open in your preferred editor and make your changes. Before you should create your branch for your development. You must create your branch from the develop branch: 1 git checkout -b <nome_branch> For the name of the branch use the number of the issue to facilitate, ex: issue_17 . And now can begin the development. When you have finished make your changes, you should commit your changes, but first: 1 git add . The above command will prepare all modified files to be committed, going through all the changes that were made by you where you will decide if the change will be added(you must be inside the project folder to use the command). Now just commit the changes: 1 git commit -m \"<Sua_Mensagem>\" Remember to use message clear. If what you're solving already has an issue open, reference issue in commit. Ex: git commit -m \"#17 - Add contributing.md\" And finally, you will submit the changes to the remote repository: 1 git push --set-upstream origin <nome_branch> This is only the first time that submit a new branch to the remote repository, next times, just: 1 git push But that will only in your fork, the official repository will not have its changes now what ? Calm down, now that the Pull Request or PR to branch develop .","title":"Clone the repository"},{"location":"CONTRIBUTING/#contribute-to-implementation","text":"After having forked and clone the project, chosen your favorite text editor. Now it's time to code. But calm there, first of all, you should choose an issue you want to work with. If the issue is about functionality does not exist, you should create and say you're working on it, case it exists, you must say that you intend to work on the issue. And after done that, now yes are you ready to code .","title":"Contribute to implementation:"},{"location":"CONTRIBUTING/#understanding-folders","text":"The project code can be found in the folder duck_orm , we are accepting library name hints as well.. In the folder duck_orm/utils : Possui os arquivos que possuem fun\u00e7\u00f5es que podem ser usadas por todo o projeto. In the folder docs : Possui os arquivos de documenta\u00e7\u00e3o da biblioteca. In the folder duck_orm/sql : Possui todos os arquivos sobre as funcionalidades relacionadas com SQL, seja do Postgres e/ou SQLite. In the folder ./postgres : Possui a classe QueryPostgres que herda de QueryExecutor, onde \u00e9 respons\u00e1vel por gerar todos os c\u00f3digos SQL que ir\u00e3o funcionar no Postgres. Se algum SQL for diferente para o banco, ent\u00e3o basta sobrescrever a fun\u00e7\u00e3o e ent\u00e3o retornar o SQL suportado. In the folder ./sqlite : Possui a classe QuerySQLite que herda de QueryExecutor, onde \u00e9 respons\u00e1vel por gerar todos os c\u00f3digos SQL que ir\u00e3o funcionar no SQLite. Se algum SQL for diferente para o banco, ent\u00e3o basta sobrescrever a fun\u00e7\u00e3o e ent\u00e3o retornar o SQL suportado. In the file ./condition.py : Possui a classe que \u00e9 usada para adicionar filtros nas consultas do DuckORM. In the file ./fields.py : Possui todas as classes que representam os tipos que s\u00e3o suportados pelo DuckORM e que fazem o tratamento para os tipos SQL. In the file ./operator.py : Possui a classe que \u00e9 usada para adicionar validar os operatores condicionais, usados pela classe Condition . In the file ./relationship.py : Possui todas as classes que representam os tipos de relacionamentos que s\u00e3o suportados pelo DuckORM e que fazem o tratamento para os relacionamentos para SQL. In the file ./sql.py : Possui a classe QueryExecutor, na qual todos as classes Query{nome_banco} herdam. \u00c9 aqui onde \u00e9 montado todos os comandos SQL e caso um SQL seja diferentes entre os bancos suportados, basta sobrescrever o m\u00e9todo na classe Query{nome_banco}. In the file ./exceptions.py : Possui todas as exce\u00e7\u00f5es usadas no DuckORM. In the file ./model.py : Principal arquivo, \u00e9 aqui onde toda a m\u00e1gica acontece. Todos os m\u00e9todos que podem ser usados por um modelo est\u00e3o nesse aquivo.","title":"Understanding folders:"},{"location":"CONTRIBUTING/#how-to-run-the-application","text":"We use poetry for easier dependency management. So you need to install it: Install poetry: To install you can follow the steps of their own documentation here Now you should create virtualenv: 1 poetry shell This will create a virtualenv for this project. Now you need to install the dependencies: 1 poetry install You are now ready to implement your functionality/fix.","title":"How to run the application:"},{"location":"CONTRIBUTING/#run-the-tests","text":"1 pytest .","title":"Run the tests:"},{"location":"CONTRIBUTING/#entering-the-standards","text":"We chose to follow the PEP 8 standard. To do this, install the Python extension for VSCode . Another solution is to use pycodestyle.","title":"Entering the standards:"},{"location":"CONTRIBUTING/#pycodestyle","text":"You can install pycodestyle with the command: 1 poetry add pycodestyle To run pycodestyle: 1 pycodestyle .","title":"Pycodestyle:"},{"location":"CONTRIBUTING/#performing-a-pull-request-pr","text":"On your fork page a yellow message will appear asking you to make a Pull Request to the original repository. Clicking will open a page for you to fill in your PR information. Reference the issue you are working on using #<numero_da_issue> . Open your PR for the develop branch. Describe your modifications. Wait for your PR evaluation, and it may happen that we ask for some changes to be made.","title":"Performing a Pull Request - PR"},{"location":"getting_started/","text":"Getting Started Installation 1 pip install duck-orm Dependencies DuckORM uses databases for database connection. Extras dependencies DuckORM can have up to 3 dependencies according to the backend database(s) you want to use: Postgresql 1 pip install duck-orm [ postgresql ] Will install also asyncpg . Postgresql + aiopg 1 pip install duck-orm [ postgresql+aiopg ] Will install also aiopg . SQLite 1 pip install duck-orm [ sqlite ] Will install also aiosqlite . Install dependencies manually If you wish, you can install the dependencies manually as well. Example: 1 pip install asyncpg","title":"Getting Started"},{"location":"getting_started/#getting-started","text":"","title":"Getting Started"},{"location":"getting_started/#installation","text":"1 pip install duck-orm","title":"Installation"},{"location":"getting_started/#dependencies","text":"DuckORM uses databases for database connection.","title":"Dependencies"},{"location":"getting_started/#extras-dependencies","text":"DuckORM can have up to 3 dependencies according to the backend database(s) you want to use:","title":"Extras dependencies"},{"location":"getting_started/#postgresql","text":"1 pip install duck-orm [ postgresql ] Will install also asyncpg .","title":"Postgresql"},{"location":"getting_started/#postgresql-aiopg","text":"1 pip install duck-orm [ postgresql+aiopg ] Will install also aiopg .","title":"Postgresql + aiopg"},{"location":"getting_started/#sqlite","text":"1 pip install duck-orm [ sqlite ] Will install also aiosqlite .","title":"SQLite"},{"location":"getting_started/#install-dependencies-manually","text":"If you wish, you can install the dependencies manually as well. Example: 1 pip install asyncpg","title":"Install dependencies manually"},{"location":"fields/","text":"Fields So far we only have 5 types available and 5 special types: ForeignKey , OneToMany , OneToOne and ManyToMany . These special types are for relationships between database tables. Tip For more details on relationship fields, see here Common Types: String 1 2 3 4 String ( unique : bool = False , primary_key : bool = False , not_null : bool = False , default_value = None ) Type in database postgres: TEXT Type in database sqlite: TEXT Type: str Integer 1 2 3 4 Integer ( min_value : int = None , unique : bool = False , primary_key : bool = False , auto_increment : bool = False , not_null : bool = False , default_value = None ) Type in database postgres: INTEGER Type in database sqlite: INTEGER Type: int BigInteger 1 2 3 BigInteger ( unique : bool = False , primary_key : bool = False , default_value = None ) Type in database postgres: BIGINT Type in database sqlite: BIGINT Type: int Varchar 1 2 3 4 Varchar ( length : int , unique : bool = False , primary_key : bool = False , default_value = None ) Type in database postgres: VARCHAR Type in database sqlite: VARCHAR Type: str Boolean 1 Boolean ( not_null : bool = False , default_value = None ) Type in database postgres: BOOLEAN Type in database sqlite: INTEGER Type: bool Timestamp 1 Timestamp () Type in database postgres: TIMESTAMP Type in database sqlite: TEXT Type: datetime","title":"Field Types"},{"location":"fields/#fields","text":"So far we only have 5 types available and 5 special types: ForeignKey , OneToMany , OneToOne and ManyToMany . These special types are for relationships between database tables. Tip For more details on relationship fields, see here","title":"Fields"},{"location":"fields/#common-types","text":"","title":"Common Types:"},{"location":"fields/#string","text":"1 2 3 4 String ( unique : bool = False , primary_key : bool = False , not_null : bool = False , default_value = None ) Type in database postgres: TEXT Type in database sqlite: TEXT Type: str","title":"String"},{"location":"fields/#integer","text":"1 2 3 4 Integer ( min_value : int = None , unique : bool = False , primary_key : bool = False , auto_increment : bool = False , not_null : bool = False , default_value = None ) Type in database postgres: INTEGER Type in database sqlite: INTEGER Type: int","title":"Integer"},{"location":"fields/#biginteger","text":"1 2 3 BigInteger ( unique : bool = False , primary_key : bool = False , default_value = None ) Type in database postgres: BIGINT Type in database sqlite: BIGINT Type: int","title":"BigInteger"},{"location":"fields/#varchar","text":"1 2 3 4 Varchar ( length : int , unique : bool = False , primary_key : bool = False , default_value = None ) Type in database postgres: VARCHAR Type in database sqlite: VARCHAR Type: str","title":"Varchar"},{"location":"fields/#boolean","text":"1 Boolean ( not_null : bool = False , default_value = None ) Type in database postgres: BOOLEAN Type in database sqlite: INTEGER Type: bool","title":"Boolean"},{"location":"fields/#timestamp","text":"1 Timestamp () Type in database postgres: TIMESTAMP Type in database sqlite: TEXT Type: datetime","title":"Timestamp"},{"location":"fields/foreignkey/","text":"ForeignKey This field is to represent the Foreign Key. Let's look at some methods this field allows. The interface of a field ForeignKey : 1 2 3 4 5 6 7 8 ForeignKey ( model : Model , name_in_table_fk : str , unique : bool = False , name_constraint : str = \"\" , on_delete : ActionsEnum = ActionsEnum . NO_ACTION . value , on_update : ActionsEnum = ActionsEnum . CASCADE . value ): Parameters: model : The Model that will be used in the relationship. name_in_table_fk : The name of the attribute that will be FK in the other model. unique : Whether this field is going to be a single value or not. name_constraint : Name for the Foreign Key constraint. If not passed, the default logic of the used database will be used. on_delete : Action ON DELETE: CASCADE , NO ACTION , RESTRICT , SET DEFAULT and SET NULL . on_update : Action ON UPDATE: CASCADE , NO ACTION , RESTRICT , SET DEFAULT and SET NULL . Examples Since this field is used to create some types of relationships, the examples of use of this field can be found in the documentation on OneToMany and ManyToMany .","title":"ForeignKey"},{"location":"fields/foreignkey/#foreignkey","text":"This field is to represent the Foreign Key. Let's look at some methods this field allows. The interface of a field ForeignKey : 1 2 3 4 5 6 7 8 ForeignKey ( model : Model , name_in_table_fk : str , unique : bool = False , name_constraint : str = \"\" , on_delete : ActionsEnum = ActionsEnum . NO_ACTION . value , on_update : ActionsEnum = ActionsEnum . CASCADE . value ): Parameters: model : The Model that will be used in the relationship. name_in_table_fk : The name of the attribute that will be FK in the other model. unique : Whether this field is going to be a single value or not. name_constraint : Name for the Foreign Key constraint. If not passed, the default logic of the used database will be used. on_delete : Action ON DELETE: CASCADE , NO ACTION , RESTRICT , SET DEFAULT and SET NULL . on_update : Action ON UPDATE: CASCADE , NO ACTION , RESTRICT , SET DEFAULT and SET NULL .","title":"ForeignKey"},{"location":"fields/foreignkey/#examples","text":"Since this field is used to create some types of relationships, the examples of use of this field can be found in the documentation on OneToMany and ManyToMany .","title":"Examples"},{"location":"fields/many_to_many/","text":"ManyToMany This field should represent the Many to Many relationship. Let's look at some methods allowed by this field. The interface of a field ManyToMany : 1 ManyToMany ( model : Model , model_relation : Model ): Parameters: model : The other Model that will be used in the relationship. model_relation : The Model that represents the relationship table between the two models. Methods Methods that are supported by the ManyToMany field. add_models Takes instance of the two relationship models and then saves it to the relationship table. 1 2 async def add_models ( model_instance_one : Model , model_instance_two : Model ) -> Model : Parameters: model_instance_one : An instance of the Model of the relation. model_instance_two : An instance of the main Model that calls the method. add Method called from an instance of one model and you must pass the instance of the other model. The relationship between the two will be saved. 1 async def add ( model_instance_one : Model ) -> Model : Parameters: model_instance_one : An instance of the Model of the relation. get_all Returns records from the other model of the relationship. 1 async def get_all () -> list [ Model ]: Examples First, let's create our templates. Examples of using the methods explained above. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 class User ( Model ): __tablename__ = 'users' __db__ = db model_manager = model_manager id : int = Field . Integer ( primary_key = True , auto_increment = True ) name : str = Field . String () @classmethod def relationships ( cls ): cls . working_day = ManyToMany ( model = WorkingDay , model_relation = UsersWorkingDay ) class WorkingDay ( Model ): __tablename__ = 'working_days' __db__ = db model_manager = model_manager id : int = Field . Integer ( primary_key = True , auto_increment = True ) week_day : str = Field . String () working_date : str = Field . String () @classmethod def relationships ( cls ): cls . users = ManyToMany ( model = User , model_relation = UsersWorkingDay ) class UsersWorkingDay ( Model ): __tablename__ = 'users_working_day' __db__ = db model_manager = model_manager id : int = Field . Integer ( primary_key = True , auto_increment = True ) @classmethod def relationships ( cls ): cls . users : User = ForeignKey ( model = User , name_in_table_fk = 'id' , name_constraint = 'user_working_day' ) cls . working_days : WorkingDay = ForeignKey ( model = WorkingDay , name_in_table_fk = 'id' , name_constraint = 'working_day_user' ) Can I use the Add and/or add_models method of the ManyToMany field to save a relationship: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 await model_manager . create_all_tables () user = await User . save ( User ( name = 'Rich' )) user1 = await User . save ( User ( name = 'Elton' )) working_day = WorkingDay ( week_day = 'segunda' , working_date = '02/08/2021' ) working_day1 = WorkingDay ( week_day = 'ter\u00e7a' , working_date = '03/08/2021' ) working_day = await WorkingDay . save ( working_day ) working_day1 = await WorkingDay . save ( working_day1 ) await User . working_day . add_models ( working_day , user ) await WorkingDay . users . add_models ( user , working_day1 ) await user1 . working_day . add ( working_day ) await user1 . working_day . add ( working_day1 ) In lines 10, 11, 13 and 14 we are creating a record in the table UsersWorkingDay which is responsible for the Many to Many relationship. Do you notice a difference between lines 10-11 and 13-14? In the first ones it uses the attribute that is not only on the instance, it calls the from the models themselves, User and WorkingDay . In the last two it uses the instance attribute of a User , so it uses this instance to save in the relationship with the record that is passed as parameter. We also have the get_all method: 1 2 3 4 5 users : list [ User ] = await working_day . users . get_all () for u in users : print ( u . id ) # 1 and 2 print ( u . name ) # 'Rich' and 'Elton'","title":"ManyToMany"},{"location":"fields/many_to_many/#manytomany","text":"This field should represent the Many to Many relationship. Let's look at some methods allowed by this field. The interface of a field ManyToMany : 1 ManyToMany ( model : Model , model_relation : Model ): Parameters: model : The other Model that will be used in the relationship. model_relation : The Model that represents the relationship table between the two models.","title":"ManyToMany"},{"location":"fields/many_to_many/#methods","text":"Methods that are supported by the ManyToMany field.","title":"Methods"},{"location":"fields/many_to_many/#add_models","text":"Takes instance of the two relationship models and then saves it to the relationship table. 1 2 async def add_models ( model_instance_one : Model , model_instance_two : Model ) -> Model : Parameters: model_instance_one : An instance of the Model of the relation. model_instance_two : An instance of the main Model that calls the method.","title":"add_models"},{"location":"fields/many_to_many/#add","text":"Method called from an instance of one model and you must pass the instance of the other model. The relationship between the two will be saved. 1 async def add ( model_instance_one : Model ) -> Model : Parameters: model_instance_one : An instance of the Model of the relation.","title":"add"},{"location":"fields/many_to_many/#get_all","text":"Returns records from the other model of the relationship. 1 async def get_all () -> list [ Model ]:","title":"get_all"},{"location":"fields/many_to_many/#examples","text":"First, let's create our templates. Examples of using the methods explained above. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 class User ( Model ): __tablename__ = 'users' __db__ = db model_manager = model_manager id : int = Field . Integer ( primary_key = True , auto_increment = True ) name : str = Field . String () @classmethod def relationships ( cls ): cls . working_day = ManyToMany ( model = WorkingDay , model_relation = UsersWorkingDay ) class WorkingDay ( Model ): __tablename__ = 'working_days' __db__ = db model_manager = model_manager id : int = Field . Integer ( primary_key = True , auto_increment = True ) week_day : str = Field . String () working_date : str = Field . String () @classmethod def relationships ( cls ): cls . users = ManyToMany ( model = User , model_relation = UsersWorkingDay ) class UsersWorkingDay ( Model ): __tablename__ = 'users_working_day' __db__ = db model_manager = model_manager id : int = Field . Integer ( primary_key = True , auto_increment = True ) @classmethod def relationships ( cls ): cls . users : User = ForeignKey ( model = User , name_in_table_fk = 'id' , name_constraint = 'user_working_day' ) cls . working_days : WorkingDay = ForeignKey ( model = WorkingDay , name_in_table_fk = 'id' , name_constraint = 'working_day_user' ) Can I use the Add and/or add_models method of the ManyToMany field to save a relationship: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 await model_manager . create_all_tables () user = await User . save ( User ( name = 'Rich' )) user1 = await User . save ( User ( name = 'Elton' )) working_day = WorkingDay ( week_day = 'segunda' , working_date = '02/08/2021' ) working_day1 = WorkingDay ( week_day = 'ter\u00e7a' , working_date = '03/08/2021' ) working_day = await WorkingDay . save ( working_day ) working_day1 = await WorkingDay . save ( working_day1 ) await User . working_day . add_models ( working_day , user ) await WorkingDay . users . add_models ( user , working_day1 ) await user1 . working_day . add ( working_day ) await user1 . working_day . add ( working_day1 ) In lines 10, 11, 13 and 14 we are creating a record in the table UsersWorkingDay which is responsible for the Many to Many relationship. Do you notice a difference between lines 10-11 and 13-14? In the first ones it uses the attribute that is not only on the instance, it calls the from the models themselves, User and WorkingDay . In the last two it uses the instance attribute of a User , so it uses this instance to save in the relationship with the record that is passed as parameter. We also have the get_all method: 1 2 3 4 5 users : list [ User ] = await working_day . users . get_all () for u in users : print ( u . id ) # 1 and 2 print ( u . name ) # 'Rich' and 'Elton'","title":"Examples"},{"location":"fields/one_to_many/","text":"OneToMany This field is to represent the One to Many relationship. Let's look at some methods this field allows. The interface of a field OneToMany : 1 OneToMany ( model : Model , name_in_table_fk : str ): Parameters: model : The other Model that will be used in the relationship. name_in_table_fk : The name of the attribute that will be FK in the other template. Methods Methods that are supported by the ManyToMany field. add M\u00e9todo que deve ser chamado de uma inst\u00e2ncia do modelo da lado do relacionamento N. 1 async def add ( model : Type [ Model ]) -> Model : Parameters: model : An instance of the Model of the relation. Examples First, let's create our models. Examples of using the methods explained above. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class City ( Model ): __tablename__ = 'cities' __db__ = db model_manager = model_manager id : int = Field . Integer ( primary_key = True , auto_increment = True ) name : str = Field . String ( unique = True ) @classmethod def relationships ( cls ): cls . persons = OneToMany ( model = Person , name_in_table_fk = 'city' ) class Person ( Model ): __tablename__ = 'persons' __db__ = db model_manager = model_manager id_teste : int = Field . Integer ( primary_key = True , auto_increment = True ) first_name : str = Field . String ( unique = True ) last_name : str = Field . String ( not_null = True ) age : int = Field . BigInteger () salary : int = Field . BigInteger () @classmethod def relationships ( cls ): cls . city : City = ForeignKey ( model = City , name_in_table_fk = 'id' , name_constraint = 'person_city_fk' ) Now let's save a city and a person and then list the people of a certain city: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 await model_manager . create_all_tables () city_cg = City ( name = \"Campina Grande\" ) person_1 = Person ( first_name = \"Rich\" , last_name = \"Carvalho\" , age = 22 , salary = 1250 , city = city_cg ) person_2 = Person ( first_name = \"Elton\" , last_name = \"Carvalho\" , age = 25 , salary = 1450 , city = city_cg ) city_cg = await City . save ( city_cg ) person_1 = await City . persons . add ( person_1 ) person_2 = await City . persons . add ( person_2 ) # Return all the people in this city persons : list [ Person ] = await City . persons . get_all () for person in persons : print ( person . first_name ) # Rich and Elton print ( person . city . name ) # Campina Grande and Campina Grande On lines 8 and 9 we are saving two people from the city of Campina Grande. And on line 11, I list the people in that city (they have relationship with that city). We also have the add method in the OneToMany field: 1 2 3 4 person_3 = Person ( first_name = \"Lucas\" , last_name = \"Andrade\" , age = 22 , salary = 1145 ) person_3 : Person = await city_cg . persons . add ( person_3 ) With that I can save a person and I already add in the city that I want to.","title":"OneToMany"},{"location":"fields/one_to_many/#onetomany","text":"This field is to represent the One to Many relationship. Let's look at some methods this field allows. The interface of a field OneToMany : 1 OneToMany ( model : Model , name_in_table_fk : str ): Parameters: model : The other Model that will be used in the relationship. name_in_table_fk : The name of the attribute that will be FK in the other template.","title":"OneToMany"},{"location":"fields/one_to_many/#methods","text":"Methods that are supported by the ManyToMany field.","title":"Methods"},{"location":"fields/one_to_many/#add","text":"M\u00e9todo que deve ser chamado de uma inst\u00e2ncia do modelo da lado do relacionamento N. 1 async def add ( model : Type [ Model ]) -> Model : Parameters: model : An instance of the Model of the relation.","title":"add"},{"location":"fields/one_to_many/#examples","text":"First, let's create our models. Examples of using the methods explained above. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class City ( Model ): __tablename__ = 'cities' __db__ = db model_manager = model_manager id : int = Field . Integer ( primary_key = True , auto_increment = True ) name : str = Field . String ( unique = True ) @classmethod def relationships ( cls ): cls . persons = OneToMany ( model = Person , name_in_table_fk = 'city' ) class Person ( Model ): __tablename__ = 'persons' __db__ = db model_manager = model_manager id_teste : int = Field . Integer ( primary_key = True , auto_increment = True ) first_name : str = Field . String ( unique = True ) last_name : str = Field . String ( not_null = True ) age : int = Field . BigInteger () salary : int = Field . BigInteger () @classmethod def relationships ( cls ): cls . city : City = ForeignKey ( model = City , name_in_table_fk = 'id' , name_constraint = 'person_city_fk' ) Now let's save a city and a person and then list the people of a certain city: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 await model_manager . create_all_tables () city_cg = City ( name = \"Campina Grande\" ) person_1 = Person ( first_name = \"Rich\" , last_name = \"Carvalho\" , age = 22 , salary = 1250 , city = city_cg ) person_2 = Person ( first_name = \"Elton\" , last_name = \"Carvalho\" , age = 25 , salary = 1450 , city = city_cg ) city_cg = await City . save ( city_cg ) person_1 = await City . persons . add ( person_1 ) person_2 = await City . persons . add ( person_2 ) # Return all the people in this city persons : list [ Person ] = await City . persons . get_all () for person in persons : print ( person . first_name ) # Rich and Elton print ( person . city . name ) # Campina Grande and Campina Grande On lines 8 and 9 we are saving two people from the city of Campina Grande. And on line 11, I list the people in that city (they have relationship with that city). We also have the add method in the OneToMany field: 1 2 3 4 person_3 = Person ( first_name = \"Lucas\" , last_name = \"Andrade\" , age = 22 , salary = 1145 ) person_3 : Person = await city_cg . persons . add ( person_3 ) With that I can save a person and I already add in the city that I want to.","title":"Examples"},{"location":"fields/one_to_one/","text":"OneToOne This field is to represent the One To One relationship. Let's look at some methods this field allows. The interface of a field OneToOne : 1 2 3 4 5 6 OneToOne ( model : Model , name_constraint : str = \"\" , on_delete : ActionsEnum = ActionsEnum . NO_ACTION . value , on_update : ActionsEnum = ActionsEnum . CASCADE . value ): Parameters: model : The Model that will be used in the relationship. name_constraint : The name of the attribute that will be FK in the other model. on_delete : Action ON DELETE: CASCADE , NO ACTION , RESTRICT , SET DEFAULT and SET NULL . on_update : Action ON UPDATE: CASCADE , NO ACTION , RESTRICT , SET DEFAULT and SET NULL . Examples Examples for these types of relationships can be found here","title":"OneToOne"},{"location":"fields/one_to_one/#onetoone","text":"This field is to represent the One To One relationship. Let's look at some methods this field allows. The interface of a field OneToOne : 1 2 3 4 5 6 OneToOne ( model : Model , name_constraint : str = \"\" , on_delete : ActionsEnum = ActionsEnum . NO_ACTION . value , on_update : ActionsEnum = ActionsEnum . CASCADE . value ): Parameters: model : The Model that will be used in the relationship. name_constraint : The name of the attribute that will be FK in the other model. on_delete : Action ON DELETE: CASCADE , NO ACTION , RESTRICT , SET DEFAULT and SET NULL . on_update : Action ON UPDATE: CASCADE , NO ACTION , RESTRICT , SET DEFAULT and SET NULL .","title":"OneToOne"},{"location":"fields/one_to_one/#examples","text":"Examples for these types of relationships can be found here","title":"Examples"},{"location":"fields/relations/","text":"Relationships The relationships supported by DuckORM are basically of two types: One to Many and Many to One are supported by the ForeignKey field. Many to Many by creating a table and making use of the ForeignKey field to relate the two tables. One to One with the OneToOne field. Let's look at some examples of using these fields. OneToMany Set the ForeignKey field to use a One-to-Many relationship. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 class City ( Model ): __tablename__ = 'cities' __db__ = db model_manager = model_manager id : int = Field . Integer ( primary_key = True , auto_increment = True ) name : str = Field . String ( unique = True ) @classmethod def relationships ( cls ): cls . persons = OneToMany ( model = Person , name_in_table_fk = 'city' , name_relation = 'person_city' ) class Person ( Model ): __tablename__ = 'persons' __db__ = db model_manager = model_manager id_teste : int = Field . Integer ( primary_key = True , auto_increment = True ) first_name : str = Field . String ( unique = True ) last_name : str = Field . String ( not_null = True ) age : int = Field . BigInteger () salary : int = Field . BigInteger () @classmethod def relationships ( cls ): cls . city : City = ForeignKey ( model = City , name_in_table_fk = 'id' , name_constraint = 'person_city_fk' ) await model_manager . create_all_tables () And with that, it will create the two tables and the persons table will have a field referencing the id field of the cities table. Every field that refers to a relationship must be placed inside the method. relationships , as this method is only executed after all tables are created. As is done in the last line, it creates all the tables and then starts doing the relationships. Note You may have also noticed the method relationships in the City class, but what will this do? This method doesn't make any changes to the database, just adds the persons: OneToMany field to the class, this field has some methods which are explained here . ManyToMany To create a Many to Many relationship we also use the ForeignKey field. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 class User ( Model ): __tablename__ = 'users' __db__ = db model_manager = model_manager id : int = Field . Integer ( primary_key = True , auto_increment = True ) name : str = Field . String () @classmethod def relationships ( cls ): cls . working_day = ManyToMany ( model = WorkingDay , model_relation = UsersWorkingDay ) class WorkingDay ( Model ): __tablename__ = 'working_days' __db__ = db model_manager = model_manager id : int = Field . Integer ( primary_key = True , auto_increment = True ) week_day : str = Field . String () working_date : str = Field . String () @classmethod def relationships ( cls ): cls . users = ManyToMany ( model = User , model_relation = UsersWorkingDay ) class UsersWorkingDay ( Model ): __tablename__ = 'users_working_day' __db__ = db model_manager = model_manager id : int = Field . Integer ( primary_key = True , auto_increment = True ) @classmethod def relationships ( cls ): cls . users : User = ForeignKey ( model = User , name_in_table_fk = 'id' , name_constraint = 'user_working_day' ) cls . working_days : WorkingDay = ForeignKey ( model = WorkingDay , name_in_table_fk = 'id' , name_constraint = 'working_day_user' ) await model_manager . create_all_tables () First we create the User and WorkingDay tables, they have a Many to Many relationship. To represent this relationship we create a third UsersWorkingDay table that has a reference to the PK of the other two tables, and thus creating the relationship. Note The relationships method in the two tables: User and WorkingDay are a little bit different from the previous example. Have the @classmethod signaling that it is a method of the class and not the instance, so it creates the users and working_day in both models. With that allowing some methods to be executed, like: User add a relationship with WorkingDay without using the UsersWorkingDay model. More examples can be seen here . OneToOne To represent the One to One relationship, just make use of the OneToOne field. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Person ( Model ): __tablename__ = 'persons' __db__ = db model_manager = model_manager id_teste : int = Field . Integer ( primary_key = True , auto_increment = True ) first_name : str = Field . String ( unique = True ) last_name : str = Field . String ( not_null = True ) age : int = Field . BigInteger () salary : int = Field . BigInteger () class Contact ( Model ): __tablename__ = 'contacts' __db__ = db model_manager = model_manager phone : str = Field . String ( not_null = True ) @classmethod def relationships ( cls ): cls . id_person = OneToOne ( model = Person , name_constraint = 'person_contact' ) We create the Person table and the Contact table. We use the OneToOne field. This field will be the PK of that table, being of the same type as the table in the relationship, in this case the same type as the PK of the Person model. To save a Contact record: 1 2 3 4 5 person_1 = Person ( first_name = \"Rich\" , last_name = \"Ramalho\" , age = 22 , salary = 1250 ) contact_person_1 = Contact ( phone = \"XXXXXXXXX-XXXX\" , id_person = person_1 ) person_1 = await Person . save ( person_1 ) contact_person_1 = await Contact . save ( contact_person_1 ) And with that, DuckORM will save the relationship contact record with this person. What happens if I try to save the same person again in a another contact? 1 2 3 4 contact_error = Contact ( phone = \"YYYYYYYYY-YYYY\" , id_person = person_1 ) await Contact . save ( contact_error ) # This line will throw a duplicate # record exception.","title":"Relations"},{"location":"fields/relations/#relationships","text":"The relationships supported by DuckORM are basically of two types: One to Many and Many to One are supported by the ForeignKey field. Many to Many by creating a table and making use of the ForeignKey field to relate the two tables. One to One with the OneToOne field. Let's look at some examples of using these fields.","title":"Relationships"},{"location":"fields/relations/#onetomany","text":"Set the ForeignKey field to use a One-to-Many relationship. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 class City ( Model ): __tablename__ = 'cities' __db__ = db model_manager = model_manager id : int = Field . Integer ( primary_key = True , auto_increment = True ) name : str = Field . String ( unique = True ) @classmethod def relationships ( cls ): cls . persons = OneToMany ( model = Person , name_in_table_fk = 'city' , name_relation = 'person_city' ) class Person ( Model ): __tablename__ = 'persons' __db__ = db model_manager = model_manager id_teste : int = Field . Integer ( primary_key = True , auto_increment = True ) first_name : str = Field . String ( unique = True ) last_name : str = Field . String ( not_null = True ) age : int = Field . BigInteger () salary : int = Field . BigInteger () @classmethod def relationships ( cls ): cls . city : City = ForeignKey ( model = City , name_in_table_fk = 'id' , name_constraint = 'person_city_fk' ) await model_manager . create_all_tables () And with that, it will create the two tables and the persons table will have a field referencing the id field of the cities table. Every field that refers to a relationship must be placed inside the method. relationships , as this method is only executed after all tables are created. As is done in the last line, it creates all the tables and then starts doing the relationships. Note You may have also noticed the method relationships in the City class, but what will this do? This method doesn't make any changes to the database, just adds the persons: OneToMany field to the class, this field has some methods which are explained here .","title":"OneToMany"},{"location":"fields/relations/#manytomany","text":"To create a Many to Many relationship we also use the ForeignKey field. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 class User ( Model ): __tablename__ = 'users' __db__ = db model_manager = model_manager id : int = Field . Integer ( primary_key = True , auto_increment = True ) name : str = Field . String () @classmethod def relationships ( cls ): cls . working_day = ManyToMany ( model = WorkingDay , model_relation = UsersWorkingDay ) class WorkingDay ( Model ): __tablename__ = 'working_days' __db__ = db model_manager = model_manager id : int = Field . Integer ( primary_key = True , auto_increment = True ) week_day : str = Field . String () working_date : str = Field . String () @classmethod def relationships ( cls ): cls . users = ManyToMany ( model = User , model_relation = UsersWorkingDay ) class UsersWorkingDay ( Model ): __tablename__ = 'users_working_day' __db__ = db model_manager = model_manager id : int = Field . Integer ( primary_key = True , auto_increment = True ) @classmethod def relationships ( cls ): cls . users : User = ForeignKey ( model = User , name_in_table_fk = 'id' , name_constraint = 'user_working_day' ) cls . working_days : WorkingDay = ForeignKey ( model = WorkingDay , name_in_table_fk = 'id' , name_constraint = 'working_day_user' ) await model_manager . create_all_tables () First we create the User and WorkingDay tables, they have a Many to Many relationship. To represent this relationship we create a third UsersWorkingDay table that has a reference to the PK of the other two tables, and thus creating the relationship. Note The relationships method in the two tables: User and WorkingDay are a little bit different from the previous example. Have the @classmethod signaling that it is a method of the class and not the instance, so it creates the users and working_day in both models. With that allowing some methods to be executed, like: User add a relationship with WorkingDay without using the UsersWorkingDay model. More examples can be seen here .","title":"ManyToMany"},{"location":"fields/relations/#onetoone","text":"To represent the One to One relationship, just make use of the OneToOne field. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Person ( Model ): __tablename__ = 'persons' __db__ = db model_manager = model_manager id_teste : int = Field . Integer ( primary_key = True , auto_increment = True ) first_name : str = Field . String ( unique = True ) last_name : str = Field . String ( not_null = True ) age : int = Field . BigInteger () salary : int = Field . BigInteger () class Contact ( Model ): __tablename__ = 'contacts' __db__ = db model_manager = model_manager phone : str = Field . String ( not_null = True ) @classmethod def relationships ( cls ): cls . id_person = OneToOne ( model = Person , name_constraint = 'person_contact' ) We create the Person table and the Contact table. We use the OneToOne field. This field will be the PK of that table, being of the same type as the table in the relationship, in this case the same type as the PK of the Person model. To save a Contact record: 1 2 3 4 5 person_1 = Person ( first_name = \"Rich\" , last_name = \"Ramalho\" , age = 22 , salary = 1250 ) contact_person_1 = Contact ( phone = \"XXXXXXXXX-XXXX\" , id_person = person_1 ) person_1 = await Person . save ( person_1 ) contact_person_1 = await Contact . save ( contact_person_1 ) And with that, DuckORM will save the relationship contact record with this person. What happens if I try to save the same person again in a another contact? 1 2 3 4 contact_error = Contact ( phone = \"YYYYYYYYY-YYYY\" , id_person = person_1 ) await Contact . save ( contact_error ) # This line will throw a duplicate # record exception.","title":"OneToOne"},{"location":"models/","text":"Models With DuckORM it's easy to create your database models and get started right away. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 from databases import Database from duck_orm.model import Model from duck_orm.model_manager import ModelManager from duck_orm.sql import fields as Field model_manager = ModelManager () db = Database ( 'sqlite:///example.db' ) await db . connect () class Person ( Model ): __tablename__ = 'persons' __db__ = db model_manager = model_manager id_teste : int = Field . Integer ( primary_key = True , auto_increment = True ) first_name : str = Field . String ( unique = True ) last_name : str = Field . String ( not_null = True ) age : int = Field . BigInteger () salary : int = Field . BigInteger () So far you've only defined a template, but you haven't told DuckORM to create a table in the database, but it's easy to do that, just add a line of code: 1 await model_manager . create_all_tables () Definition of fields And then just define the table fields . Basic Types For each table created, it must necessarily have a field with the attribute primary_key=True . And only one primary_key column is allowed. 1 2 3 4 5 6 7 8 9 10 class Person ( Model ): __tablename__ = 'persons' __db__ = db model_manager = model_manager id_teste : int = Field . Integer ( primary_key = True , auto_increment = True ) first_name : str = Field . String ( unique = True ) last_name : str = Field . String ( not_null = True ) age : int = Field . BigInteger () salary : int = Field . BigInteger () Warning You should not assign more than one primary_key to more than one column in the same table. Dependencies DuckORM depends on databases library to connect to the database. Table name Another important parameter is __tablename__ , which is used to set the name of your Model in the database. 1 2 3 4 5 6 7 8 9 10 class Person ( Model ): __tablename__ = 'persons' __db__ = db model_manager = model_manager id_teste : int = Field . Integer ( primary_key = True , auto_increment = True ) first_name : str = Field . String ( unique = True ) last_name : str = Field . String ( not_null = True ) age : int = Field . BigInteger () salary : int = Field . BigInteger () Tip If you don't pass the __tablename__ attribute, the table name will be defined by the name of the Model . Example: In the case above, if the __tablename__ attribute was not passed, the name of the table would be person . Databases This parameter is __db__ , and it is the instance create, bith your database URL string. This instance needs to be passed to the Model . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 from databases import Database from duck_orm.model import Model from duck_orm.sql import fields as Field db = Database ( 'sqlite:///example.db' ) await db . connect () class Person ( Model ): __tablename__ = 'persons' __db__ = db model_manager = model_manager id_teste : int = Field . Integer ( primary_key = True , auto_increment = True ) first_name : str = Field . String ( unique = True ) last_name : str = Field . String ( not_null = True ) age : int = Field . BigInteger () salary : int = Field . BigInteger () Tip You must create the databases instance only once and then use it for all models of your system, but nothing stops you from creating multiple instances Another important parameter is tablename , which is used to set the name of your Model in the database. if you want to use multiple databases . Model Manager: It is the database model manager. It is he who has the methods to create all the tables and their relationships. 1 2 3 4 5 6 7 8 9 10 class Person ( Model ): __tablename__ = 'persons' __db__ = db model_manager = model_manager id_teste : int = Field . Integer ( primary_key = True , auto_increment = True ) first_name : str = Field . String ( unique = True ) last_name : str = Field . String ( not_null = True ) age : int = Field . BigInteger () salary : int = Field . BigInteger ()","title":"Definition"},{"location":"models/#models","text":"With DuckORM it's easy to create your database models and get started right away. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 from databases import Database from duck_orm.model import Model from duck_orm.model_manager import ModelManager from duck_orm.sql import fields as Field model_manager = ModelManager () db = Database ( 'sqlite:///example.db' ) await db . connect () class Person ( Model ): __tablename__ = 'persons' __db__ = db model_manager = model_manager id_teste : int = Field . Integer ( primary_key = True , auto_increment = True ) first_name : str = Field . String ( unique = True ) last_name : str = Field . String ( not_null = True ) age : int = Field . BigInteger () salary : int = Field . BigInteger () So far you've only defined a template, but you haven't told DuckORM to create a table in the database, but it's easy to do that, just add a line of code: 1 await model_manager . create_all_tables ()","title":"Models"},{"location":"models/#definition-of-fields","text":"And then just define the table fields .","title":"Definition of fields"},{"location":"models/#basic-types","text":"For each table created, it must necessarily have a field with the attribute primary_key=True . And only one primary_key column is allowed. 1 2 3 4 5 6 7 8 9 10 class Person ( Model ): __tablename__ = 'persons' __db__ = db model_manager = model_manager id_teste : int = Field . Integer ( primary_key = True , auto_increment = True ) first_name : str = Field . String ( unique = True ) last_name : str = Field . String ( not_null = True ) age : int = Field . BigInteger () salary : int = Field . BigInteger () Warning You should not assign more than one primary_key to more than one column in the same table.","title":"Basic Types"},{"location":"models/#dependencies","text":"DuckORM depends on databases library to connect to the database.","title":"Dependencies"},{"location":"models/#table-name","text":"Another important parameter is __tablename__ , which is used to set the name of your Model in the database. 1 2 3 4 5 6 7 8 9 10 class Person ( Model ): __tablename__ = 'persons' __db__ = db model_manager = model_manager id_teste : int = Field . Integer ( primary_key = True , auto_increment = True ) first_name : str = Field . String ( unique = True ) last_name : str = Field . String ( not_null = True ) age : int = Field . BigInteger () salary : int = Field . BigInteger () Tip If you don't pass the __tablename__ attribute, the table name will be defined by the name of the Model . Example: In the case above, if the __tablename__ attribute was not passed, the name of the table would be person .","title":"Table name"},{"location":"models/#databases","text":"This parameter is __db__ , and it is the instance create, bith your database URL string. This instance needs to be passed to the Model . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 from databases import Database from duck_orm.model import Model from duck_orm.sql import fields as Field db = Database ( 'sqlite:///example.db' ) await db . connect () class Person ( Model ): __tablename__ = 'persons' __db__ = db model_manager = model_manager id_teste : int = Field . Integer ( primary_key = True , auto_increment = True ) first_name : str = Field . String ( unique = True ) last_name : str = Field . String ( not_null = True ) age : int = Field . BigInteger () salary : int = Field . BigInteger () Tip You must create the databases instance only once and then use it for all models of your system, but nothing stops you from creating multiple instances Another important parameter is tablename , which is used to set the name of your Model in the database. if you want to use multiple databases .","title":"Databases"},{"location":"models/#model-manager","text":"It is the database model manager. It is he who has the methods to create all the tables and their relationships. 1 2 3 4 5 6 7 8 9 10 class Person ( Model ): __tablename__ = 'persons' __db__ = db model_manager = model_manager id_teste : int = Field . Integer ( primary_key = True , auto_increment = True ) first_name : str = Field . String ( unique = True ) last_name : str = Field . String ( not_null = True ) age : int = Field . BigInteger () salary : int = Field . BigInteger ()","title":"Model Manager:"},{"location":"models/methods/","text":"Methods Here we will show some methods that the Model has and we will also see how to use each one of them. To run the examples run using ipython . get_name Method that returns the name of the Model in the database. And if the __tablename__ attribute has not been assigned in the Model , then this method will return the class name in lowercase. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Person ( Model ): __db__ = db id : int = Field . Integer ( primary_key = True , auto_increment = True ) first_name : str = Field . String ( unique = True ) Person . get_name () # will return 'person'. class Client ( Model ): __tablename__ = 'clients' __db__ = db # definitions of fields ... Client . get_name () # Will return 'clients'. create Asynchronous method that will create the table that represents the Model in the database. It should always be used before trying to save, search or delete an object of the Model . 1 2 3 4 5 6 7 8 9 10 11 class Person ( Model ): __tablename__ = 'persons' __db__ = db id : int = Field . Integer ( primary_key = True , auto_increment = True ) first_name : str = Field . String ( unique = True ) last_name : str = Field . String ( not_null = True ) age : int = Field . BigInteger ( min_value = 18 ) salary : int = Field . BigInteger () await Person . create () save 1 save ( model : Model ) -> Model : Asynchronous method that will save an object to the table in the database. Parameters: model : Model instance with fields filled. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 ... person_1 = Person ( first_name = \"Teste 1\" , last_name = \"teste lastname\" , age = 19 , salary = 5000 ) person_2 = Person ( first_name = \"Teste 2\" , last_name = \"teste lastname\" , age = 25 , salary = 4000 ) person_3 = Person ( first_name = \"Teste 3\" , last_name = \"teste lastname\" , age = 22 , salary = 2500 ) person_1 = await Person . save ( person_1 ) person_2 = await Person . save ( person_2 ) person_3 = await Person . save ( person_3 ) person_1 . id # 1 person_1 . first_name # Teste 1 person_1 . age # 19 person_2 . id # 2 person_2 . first_name # Teste 2 person_2 . age # 25 person_3 . id # 3 person_3 . first_name # Teste 3 person_3 . age # 22 find_all 1 2 3 4 5 6 find_all ( fields_includes : List [ str ] = [], fields_excludes : List [ str ] = [], conditions : List [ Condition ] = [], limit : int = None ) -> List [ Model ] Asynchronous method that retrieves all objects persisted in a table in the database. Parameters: fields_includes : The Model fields that are to be retrieved. fields_excludes : The Model fields that should not be retrieved. conditions : Conditions for filtering objects. limit : The maximum limit of objects that must be retrieved. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 ... from duck_orm.sql.condition import Condition persons : list [ Person ] = await Person . find_all ( fields_includes = [ 'first_name' , 'age' , 'salary' ], # I could have left this parameter blank as it is no longer in # fields_includes. fields_excludes = [ 'id' ], conditions = [ Condition ( 'first_name' , 'LIKE' , 'Teste%' ), Condition ( 'salary' , '>=' , 2600 ) ] ) for person in persons : print ( person . id ) # None in all. print ( person . first_name ) # Teste 1, Teste 2 print ( person . age ) # 19, 25 print ( person . salary ) # 5000, 4000 find_one 1 2 3 4 5 find_one ( fields_includes : List [ str ] = [], fields_excludes : List [ str ] = [], conditions : List [ Condition ] = [], ) -> Model Asynchronous method that retrieves only one object persisted in a table in the database. If you pass the filtering condition by the key field, this method can be used as a find by id. Parameters: fields_includes : The Model fields that are to be retrieved. fields_excludes : The Model fields that should not be retrieved. conditions : The conditions for filtering the object. 1 2 3 4 5 6 7 8 9 10 11 person : Person = await Person . find_one ( conditions = [ Condition ( 'id' , '=' , 1 ) ] ) print ( person . id ) # 1 print ( person . first_name ) # Teste 1 print ( person . last_name ) # teste lastname print ( person . age ) # 19 print ( person . salary ) # 5000 find_by_id 1 2 3 4 5 find_by_id ( id : Any , fields_includes : List [ str ] = [], fields_excludes : List [ str ] = [] ) -> Model Asynchronous method will do a lookup by model id Parameters: id : Id value of model. fields_includes : The Model fields that are to be retrieved. fields_excludes : The Model fields that should not be retrieved. conditions : The conditions for filtering the object. 1 2 3 4 5 6 7 person : Person = await Person . find_by_id ( 1 ) print ( person . id ) # 1 print ( person . first_name ) # Teste 1 print ( person . last_name ) # teste lastname print ( person . age ) # 19 print ( person . salary ) # 5000 find_all_tables 1 async def find_all_tables (): Asynchronous method that returns all table names persisted in the database. 1 print ( await Person . find_all_tables ()) update 1 async def update ( ** kwargs ) -> Model : Asynchronous method to alter a record persisted in the database. Parameters: kwargs : A dictionary with the Model fields that must be changed and its new values. 1 2 3 4 5 6 7 8 9 10 11 12 13 person : Person = await Person . find_one ( conditions = [ Condition ( 'id' , '=' , 1 ) ] ) print ( person . id ) # 1 person : Person = await person . update ( first_name = 'Teste 1 UPDATE' , age = 22 ) print ( person . id ) # 1 print ( person . first_name ) # Teste 1 UPDATE print ( person . age ) # 22 delete 1 async def delete ( conditions : List [ Condition ]): Asynchronous method that deletes a record from the database. Parameters: conditions : The conditions for filtering the record(s). 1 2 3 4 5 person : Person = await Person . delete ( conditions = [ Condition ( 'id' , '=' , 1 ) ] )","title":"Methods"},{"location":"models/methods/#methods","text":"Here we will show some methods that the Model has and we will also see how to use each one of them. To run the examples run using ipython .","title":"Methods"},{"location":"models/methods/#get_name","text":"Method that returns the name of the Model in the database. And if the __tablename__ attribute has not been assigned in the Model , then this method will return the class name in lowercase. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Person ( Model ): __db__ = db id : int = Field . Integer ( primary_key = True , auto_increment = True ) first_name : str = Field . String ( unique = True ) Person . get_name () # will return 'person'. class Client ( Model ): __tablename__ = 'clients' __db__ = db # definitions of fields ... Client . get_name () # Will return 'clients'.","title":"get_name"},{"location":"models/methods/#create","text":"Asynchronous method that will create the table that represents the Model in the database. It should always be used before trying to save, search or delete an object of the Model . 1 2 3 4 5 6 7 8 9 10 11 class Person ( Model ): __tablename__ = 'persons' __db__ = db id : int = Field . Integer ( primary_key = True , auto_increment = True ) first_name : str = Field . String ( unique = True ) last_name : str = Field . String ( not_null = True ) age : int = Field . BigInteger ( min_value = 18 ) salary : int = Field . BigInteger () await Person . create ()","title":"create"},{"location":"models/methods/#save","text":"1 save ( model : Model ) -> Model : Asynchronous method that will save an object to the table in the database. Parameters: model : Model instance with fields filled. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 ... person_1 = Person ( first_name = \"Teste 1\" , last_name = \"teste lastname\" , age = 19 , salary = 5000 ) person_2 = Person ( first_name = \"Teste 2\" , last_name = \"teste lastname\" , age = 25 , salary = 4000 ) person_3 = Person ( first_name = \"Teste 3\" , last_name = \"teste lastname\" , age = 22 , salary = 2500 ) person_1 = await Person . save ( person_1 ) person_2 = await Person . save ( person_2 ) person_3 = await Person . save ( person_3 ) person_1 . id # 1 person_1 . first_name # Teste 1 person_1 . age # 19 person_2 . id # 2 person_2 . first_name # Teste 2 person_2 . age # 25 person_3 . id # 3 person_3 . first_name # Teste 3 person_3 . age # 22","title":"save"},{"location":"models/methods/#find_all","text":"1 2 3 4 5 6 find_all ( fields_includes : List [ str ] = [], fields_excludes : List [ str ] = [], conditions : List [ Condition ] = [], limit : int = None ) -> List [ Model ] Asynchronous method that retrieves all objects persisted in a table in the database. Parameters: fields_includes : The Model fields that are to be retrieved. fields_excludes : The Model fields that should not be retrieved. conditions : Conditions for filtering objects. limit : The maximum limit of objects that must be retrieved. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 ... from duck_orm.sql.condition import Condition persons : list [ Person ] = await Person . find_all ( fields_includes = [ 'first_name' , 'age' , 'salary' ], # I could have left this parameter blank as it is no longer in # fields_includes. fields_excludes = [ 'id' ], conditions = [ Condition ( 'first_name' , 'LIKE' , 'Teste%' ), Condition ( 'salary' , '>=' , 2600 ) ] ) for person in persons : print ( person . id ) # None in all. print ( person . first_name ) # Teste 1, Teste 2 print ( person . age ) # 19, 25 print ( person . salary ) # 5000, 4000","title":"find_all"},{"location":"models/methods/#find_one","text":"1 2 3 4 5 find_one ( fields_includes : List [ str ] = [], fields_excludes : List [ str ] = [], conditions : List [ Condition ] = [], ) -> Model Asynchronous method that retrieves only one object persisted in a table in the database. If you pass the filtering condition by the key field, this method can be used as a find by id. Parameters: fields_includes : The Model fields that are to be retrieved. fields_excludes : The Model fields that should not be retrieved. conditions : The conditions for filtering the object. 1 2 3 4 5 6 7 8 9 10 11 person : Person = await Person . find_one ( conditions = [ Condition ( 'id' , '=' , 1 ) ] ) print ( person . id ) # 1 print ( person . first_name ) # Teste 1 print ( person . last_name ) # teste lastname print ( person . age ) # 19 print ( person . salary ) # 5000","title":"find_one"},{"location":"models/methods/#find_by_id","text":"1 2 3 4 5 find_by_id ( id : Any , fields_includes : List [ str ] = [], fields_excludes : List [ str ] = [] ) -> Model Asynchronous method will do a lookup by model id Parameters: id : Id value of model. fields_includes : The Model fields that are to be retrieved. fields_excludes : The Model fields that should not be retrieved. conditions : The conditions for filtering the object. 1 2 3 4 5 6 7 person : Person = await Person . find_by_id ( 1 ) print ( person . id ) # 1 print ( person . first_name ) # Teste 1 print ( person . last_name ) # teste lastname print ( person . age ) # 19 print ( person . salary ) # 5000","title":"find_by_id"},{"location":"models/methods/#find_all_tables","text":"1 async def find_all_tables (): Asynchronous method that returns all table names persisted in the database. 1 print ( await Person . find_all_tables ())","title":"find_all_tables"},{"location":"models/methods/#update","text":"1 async def update ( ** kwargs ) -> Model : Asynchronous method to alter a record persisted in the database. Parameters: kwargs : A dictionary with the Model fields that must be changed and its new values. 1 2 3 4 5 6 7 8 9 10 11 12 13 person : Person = await Person . find_one ( conditions = [ Condition ( 'id' , '=' , 1 ) ] ) print ( person . id ) # 1 person : Person = await person . update ( first_name = 'Teste 1 UPDATE' , age = 22 ) print ( person . id ) # 1 print ( person . first_name ) # Teste 1 UPDATE print ( person . age ) # 22","title":"update"},{"location":"models/methods/#delete","text":"1 async def delete ( conditions : List [ Condition ]): Asynchronous method that deletes a record from the database. Parameters: conditions : The conditions for filtering the record(s). 1 2 3 4 5 person : Person = await Person . delete ( conditions = [ Condition ( 'id' , '=' , 1 ) ] )","title":"delete"}]}